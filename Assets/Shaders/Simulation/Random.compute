
#ifndef _RANDOM_COMPUTE_INCLUDED
#define _RANDOM_COMPUTE_INCLUDED

#include "Assets/Shaders/Simulation/Uniforms.compute"

uint rngIndex(uint threadIndex)
{
    return threadIndex % _rngCount;
}

uint rngMod(uint n) 
{
    return ((n % _rngMax) + _rngMax) % _rngMax;
}

uint rng(uint rngIndex)
{
    uint result = 0;
    uint prevPos = 1;
    uint nextPos = 0;
    uint exchangedPos = 0;
    
    uint rngOffset = rngIndex*(_rngStateLength+1);

    [allow_uav_condition]
    while( prevPos != exchangedPos )
    {
        prevPos = _rngState[rngOffset];
        nextPos = (prevPos + 1) % _rngStateLength;
        
        InterlockedCompareExchange( _rngState[rngOffset], prevPos, nextPos, exchangedPos );

        if (exchangedPos == prevPos)
        {
            uint p0 = rngOffset + 1; 
            uint p1 = (prevPos + 1) % _rngStateLength;
            uint p2 = (prevPos + _rngStateLength / 2 + _rngStateLength / 11) % _rngStateLength;
            result = rngMod( _rngState[p0+p1] - _rngState[p0+p2] );
            _rngState[p0 + prevPos] = result;
        }
    }
    return result; 
}

float rngRange(float min, float max, uint rngIndex)
{
    return min + (max - min) * ((float)( rng( rngIndex ) )) / _rngMax; 
}

float rngNormal(uint rngIndex)
{
    return rngRange(0.0f, 1.0f, rngIndex) * rngRange( -1.0f, 1.0f, rngIndex );
}

#endif